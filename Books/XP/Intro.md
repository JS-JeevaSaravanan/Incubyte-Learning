



 XP describes an approach to development that combines practices used by many successful developers that got buried under the massive literature on software methods and process. Like patterns, XP builds on best practices such as unit testing, pair programming, and refactoring






XP is a lightweight methodology for small-to-medium-sized teams developing software in the face of vague or rapidly changing requirements. This book is intended to help you decide if XP is for you.







XP takes commonsense principles and practices to extreme levels.

- If code reviews are good, we'll review code all the time (pair programming).
    
- If testing is good, everybody will test all the time (unit testing), even the customers (functional testing).
    
- If design is good, we'll make it part of everybody's daily business (refactoring).
    
- If simplicity is good, we'll always leave the system with the simplest design that supports its current functionality (the simplest thing that could possibly work).
    
- If architecture is important, everybody will work defining and refining the architecture all the time (metaphor).
    
- If integration testing is important, then we'll integrate and test several times a day (continuous integration).
    
- If short iterations are good, we'll make the iterations really, really short—seconds and minutes and hours, not weeks and months and years (the Planning Game).







XP makes two sets of promises.

- To programmers, XP promises that they will be able to work on things that really matter, every day. They won't have to face scary situations alone. They will be able to do everything in their power to make their system successful. They will make decisions that they can make best, and they won't make decisions they they aren't best qualified to make.
    
- To customers and managers, XP promises that they will get the most possible value out of every programming week. Every few weeks they will be able to see concrete progress on goals they care about. They will be able to change the direction of the project in the middle of development without incurring exorbitant costs.





In short, XP promises to reduce project risk, improve responsiveness to business changes, improve productivity throughout the life of a system, and add fun to building software in teams—all at the same time. Really. Quit laughing. Now you'll have to read the rest of the book to see if I'm crazy.





What is XP? XP is a lightweight, efficient, low-risk, flexible, predictable, scientific, and fun way to develop software. It is distinguished from other methodologies by

- Its early, concrete, and continuing feedback from short cycles.
    
- Its incremental planning approach, which quickly comes up with an overall plan that is expected to evolve through the life of the project.
    
- Its ability to flexibly schedule the implementation of functionality, responding to changing business needs.
    
- Its reliance on automated tests written by programmers and customers to monitor the progress of development, to allow the system to evolve, and to catch defects early.
    
- Its reliance on oral communication, tests, and source code to communicate system structure and intent.
    
- Its reliance on an evolutionary design process that lasts as long as the system lasts.
    
- Its reliance on the close collaboration of programmers with ordinary skills.
    
- Its reliance on practices that work with both the short-term instincts of programmers and the long-term interests of the project.
    

XP is a discipline of software development. It is a discipline because there are certain things that you have to do to be doing XP. You don't get to choose whether or not you will write tests—if you don't, you aren't extreme: end of discussion.



--


The innovation of XP is

- Putting all these practices under one umbrella.
    
- Making sure they are practiced as thoroughly as possible.
    
- Making sure the practices support each other to the greatest possible degree.

--


XP is an experiment in answer to the question, "How would you program if you had enough time?" Now, you can't have extra time, because this is business after all, and we are certainly playing to win. But if you had enough time, you would write tests; you would restructure the system when you learned something; you would talk a lot with fellow programmers and with the customer.


--

3 sections 

The book is divided into three sections.

- **The Problem—.** The chapters from "Risk: The Basic Problem" to "Back to Basics" set up the problem Extreme Programming is trying to solve and present criteria for evaluating the solution. This section will give you an idea of the overall worldview of Extreme Programming.
    
- **The Solution—.** The chapters from "Quick Overview" to "Testing Strategy" turn the abstract ideas in the first section into the practices of a concrete methodology. This section will not tell you exactly how you can execute the practices, but rather talks about their general shape. The discussion of each practice relates it to the problems and principles introduced in the first section.
    
- **Implementing XP—.** The chapters from "Adopting XP" to "XP at Work" describe a variety of topics around implementing XP—how to adopt it, what is expected from the various people in an extreme project, how XP looks to the business folks.

--












